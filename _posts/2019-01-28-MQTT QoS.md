---
layout: splash
title:  "MQTT QoS"
date:   2019-01-28 19:13:44 +0800
categories: TCP/IP
header:
  overlay_image: /assets/images/IMGP8176.jpg
excerpt: >
     
tags: 
  - MQTT
---
# 服务质量
服务质量（QoS）级别是消息的发送者和接收者之间的协定，它定义了指定消息的传递保障。MQTT中有三个QoS级别
* 最多一次（0）
* 最少一次（1）
* 刚好一次（2）

当我们谈及MQTT中的QoS时，应当考虑消息传递的两个方面：
* 消息从发布方客户端传递到broker
* 消息从broker传递到消息的订阅方客户端

我们将分别观察消息传递的两方面，由于它们之间些许的不同。当消息发布方客户端向broker发送消息时，它指定了消息的QoS级别。当broker将消息发送给订阅客户端时，分别使用各个订阅时指定的QoS级别。如果订阅客户端使用了比发布客户端低的QoS，broker就使用这个低的QoS来传递消息。

# 为什么服务质量很重要
QoS是MQTT协议的关键特性，QoS使客户能够选择与其网络可靠性和应用逻辑相匹配的服务级别。正是由于MQTT管理消息重传并保证消息到达（即使底层传输不可靠），QoS使得不可靠网络中的通信变得更加容易。

# 它是如何工作的
让我们仔细研究一下MQTT协议中每个QoS级别的实现方式及其运行方式：
## QoS 0 —— 最多一次
QoS最低等级是零。这个服务级别保证尽力送达。但不保证一定能送达。消息的接收者不确认收到，并且消息的发送者也不保存和重传消息。QoS级别0通常称为“即发即忘”，并提供与底层TCP协议相同的保证。

![QoS 0](https://www.hivemq.com/img/blog/QoS-0.png)

## QoS 1 —— 最少一次
QoS1 保证消息至少送达接收者一次。发送者保存消息，直到它收到来自消息接收者的确认收到消息的`PUBACK`数据包。一条消息可能会发送或送达多次。

![QoS 1](https://www.hivemq.com/img/blog/QoS-1.png)

![PUBACK](https://www.hivemq.com/img/blog/puback_packet.png)

消息发送者使用Packet Id将`PUBLISH`与相应的PUBACK进行匹配。如果发送方在合理的时间内未收到PUBACK，则发送方重新发送`PUBLISH`。当接收方收到一条QoS 1的消息时，它可以立即处理它。例如，消息的接收方是broker，则broker将这条消息发送给所有订阅的客户端，然后回复发送方一个PUBACK。如果发送方重复发送消息，则会设置重复（DUP）标识。在QoS1中，此DUP标识仅用于内部使用，broker和客户端都不会处理它。无论DUP标志是否设置，消息的接收者都发送PUBACK。

## QoS 2 —— 刚好一次
QoS 2是MQTT中的最高服务级别。这个服务级别保证每条消息的预期接收者接收一次。QoS 2提供最安全的服务质量，也最慢。这项保证至少由发送者和接收者之间的两个请求/响应流（四部分握手）提供。消息的发送者和接收者之间使用原始的`PUBLISH`消息中的Packet Id来协调消息的传送。

![QoS 1](https://www.hivemq.com/img/blog/QoS-2.png)

当消息接收者收到一条QoS 2的消息时，它会相应的处理消息，并使用确认`PUBLISH`的`PUBREC`回复发送方。如果发送方没有收到消息接收者确认`PUBLISH`的`PUBREC`，它会再次发送带有重复（DUP）标识的`PUBLISH`，直到它收到确认为止。

![PUBREC](https://www.hivemq.com/img/blog/pubrec_packet.png)

一旦消息发送者收到来自接收者的`PUBREC`，发送者可以安全的丢弃最初的`PUBLISH`，发送者保存来自消息接收者的`PUBREC`，并响应一个`PUBREL`。

![PUBREL](https://www.hivemq.com/img/blog/pubrel_packet.png)

消息接收方收到`PUBREL`，它可以丢弃所有已保存的状态，并回应一个`PUBCOMP`（消息发送者收到`PUBCOMP`后也一样）。消息的接收方保存着原始`PUBLISH`中的Packet Id，直到接收者完成消息处理并向消息发送者发送一条`PUBCOMP`。这一步十分重要，用于避免重复处理同一条消息。发送者收到`PUBCOMP`之后，该`PUBLISH`中的PacketId重新变成可用状态。

![PUBCOMP](https://www.hivemq.com/img/blog/pubcomp_packet.png)

当QoS 2流程完成时，两边都确认消息成功投递，发送者得到了消息送达确认。
如果Packet在中途丢失，则Packet的发送者有责任在合理时间内重新发送消息，无论发送者是broker还是客户端。接收者有责任相应的回应收到的每一条命令消息。

# 不可不知
QoS某些方面乍一看并不是很明显，使用QoS时，请记住以下几点：

## QoS降级
正如我哦们已经提到的，发送（PUBLISH）消息的客户端和接收消息的客户端之间的QoS定义和级别是两个不同的东西。这两种交互的QoS级别也可以不同。向broker发送PUBLISH消息的客户端定义了消息的QoS。但是，当broker传递消息给接收者（订阅者）时，broker使用接收者（订阅者）订阅期间指定的QoS。举个例子，客户端A是消息的发送者，客户端B是消息的接收者。如果客户端B使用QoS 1订阅到broker，客户端A使用QoS 2发送消息给broker，则broker就会以QoS 1将消息传递给客户端B（接收者/订阅者）。消息可能会多次传递给B，这是由于QoS 1保证消息至少传递一次，并且不会防止同一条消息多次传递。

## Packet Id对于每个客户端是唯一的
MQTT在特定客户端和broker的QoS1、QoS2交互中使用的的Packet Id的唯一的，但Packet Id在所有的客户度之间不是惟一的。流程完成后，Packet Id可供重复使用，重用机制是Packet Id不需要超过65535的原因，客户端没有完成交互的情况下无法发送超过65535条消息（因为交互没完成，PacketId不能重用）。

# 最佳实践
我们经常被问及有关如何选择正确的QoS级别的建议。以下是一些可以帮助您制定决策的指南。QoS是否适合您在很大程度上取决于您的使用案例。

## 何时使用QoS 0
* 发送方和接收方之间的连接完全或大多数情况下是稳定的。一个QoS 0的典型案例是通过有线连接将一个测试客户端或前端应用连接到broker上。

* 你不介意偶然丢失的一些消息。如果数据不是那么重要或者数据发送间隔很短，则可以接受部分消息丢失。

* 你不需要离线消息。只有当离线的客户端具有持久会话，并且消息的QoS为1或2时，broker才会为它们保存消息。

## 何时使用QoS 1
* 你需要获取每条消息，并且你的用力可以处理重复。QoS 1是最经常使用的服务等及，这是由于它保证消息至少送达一次但允许重复送达。当然，你的应用必须能够容忍消息重复并能够按需处理它们。

* 你无法接受QoS 2的开销。QoS 1能够比QoS 2更快的传递消息。

## 何时使用QoS 2
* 对于你的应用程序来说，所有消息仅接收一次至关重要，重复传递消息可能会损害应用程序用户或订阅客户端，则使用QoS 2。注意QoS 2的开销很大，并且QoS 2交互需要更长时间来完成。


# QoS 1和QoS 2的离线消息
所有以QoS 1和QoS 2发送给离线客户端的消息将暂时缓存起来，直到它们再次上线。然而，只有当离线客户端具有持久会话时，才能够使用这一特性。